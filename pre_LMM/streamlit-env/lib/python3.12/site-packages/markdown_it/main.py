from __future__ import annotations

from collections.abc import Callable, Generator, Iterable, Mapping, MutableMapping
from contextlib import contextmanager
from typing import Any, Literal, overload

# 内部モジュールのインポート
from . import helpers, presets
from .common import normalize_url, utils
from .parser_block import ParserBlock
from .parser_core import ParserCore
from .parser_inline import ParserInline
from .renderer import RendererHTML, RendererProtocol
from .rules_core.state_core import StateCore
from .token import Token
from .utils import EnvType, OptionsDict, OptionsType, PresetType

try:
    import linkify_it
except ModuleNotFoundError:
    linkify_it = None

# プリセット設定（preset名とその設定を紐付ける）
_PRESETS: dict[str, PresetType] = {
    "default": presets.default.make(),
    "js-default": presets.js_default.make(),
    "zero": presets.zero.make(),
    "commonmark": presets.commonmark.make(),
    "gfm-like": presets.gfm_like.make(),
}


class MarkdownIt:
    def __init__(
        self,
        config: str | PresetType = "commonmark",
        options_update: Mapping[str, Any] | None = None,
        *,
        renderer_cls: Callable[[MarkdownIt], RendererProtocol] = RendererHTML,
    ) -> None:
        """
        メインのパーサークラス

        :param config: ロードする設定のプリセット名または設定辞書（デフォルトは "commonmark"）
        :param options_update: config["options"] にマージする辞書
        :param renderer_cls: レンダラークラス（デフォルトは RendererHTML）
        """
        # 内部ユーティリティの設定
        self.utils = utils
        self.helpers = helpers

        # 各パーサーコンポーネントの初期化
        self.inline = ParserInline()
        self.block = ParserBlock()
        self.core = ParserCore()
        self.renderer = renderer_cls(self)
        self.linkify = linkify_it.LinkifyIt() if linkify_it else None

        # 設定の反映
        if options_update is not None and not isinstance(options_update, Mapping):
            raise TypeError(
                f"options_update should be a mapping: {options_update}\n"
                "(Perhaps you intended this to be the renderer_cls?)"
            )
        self.configure(config, options_update=options_update)

    def __repr__(self) -> str:
        return f"{self.__class__.__module__}.{self.__class__.__name__}()"

    @overload
    def __getitem__(self, name: Literal["inline"]) -> ParserInline:
        ...

    @overload
    def __getitem__(self, name: Literal["block"]) -> ParserBlock:
        ...

    @overload
    def __getitem__(self, name: Literal["core"]) -> ParserCore:
        ...

    @overload
    def __getitem__(self, name: Literal["renderer"]) -> RendererProtocol:
        ...

    @overload
    def __getitem__(self, name: str) -> Any:
        ...

    def __getitem__(self, name: str) -> Any:
        mapping = {
            "inline": self.inline,
            "block": self.block,
            "core": self.core,
            "renderer": self.renderer,
        }
        return mapping[name]

    def set(self, options: OptionsType) -> None:
        """
        パーサーオプションを設定する

        __Note__: オンザフライでオプションを変更するのは推奨されません。
        複数の設定が必要な場合は、インスタンスを別々に生成してください。
        """
        self.options = OptionsDict(options)

    def configure(
        self, presets: str | PresetType, options_update: Mapping[str, Any] | None = None
    ) -> MarkdownIt:
        """
        設定とコンポーネントの一括ロード

        :param presets: プリセット名または設定辞書
        :param options_update: 設定更新用の辞書
        :return: 自身のインスタンス（チェーンメソッド対応）
        """
        if isinstance(presets, str):
            if presets not in _PRESETS:
                raise KeyError(f"Wrong `markdown-it` preset '{presets}', check name")
            config = _PRESETS[presets]
        else:
            config = presets

        if not config:
            raise ValueError("Wrong `markdown-it` config, can't be empty")

        # オプションのマージ
        options = config.get("options", {}) or {}
        if options_update:
            options = {**options, **options_update}

        self.set(options)

        # コンポーネントの設定
        if "components" in config:
            for name, component in config["components"].items():
                if rules := component.get("rules"):
                    self[name].ruler.enableOnly(rules)
                if rules2 := component.get("rules2"):
                    self[name].ruler2.enableOnly(rules2)

        return self

    def get_all_rules(self) -> dict[str, list[str]]:
        """
        全ルールの名前を返す

        :return: 各チェーンごとのルールリストを含む辞書
        """
        rules = {
            chain: self[chain].ruler.get_all_rules()
            for chain in ["core", "block", "inline"]
        }
        rules["inline2"] = self.inline.ruler2.get_all_rules()
        return rules

    def get_active_rules(self) -> dict[str, list[str]]:
        """
        現在有効なルールの名前を返す

        :return: 各チェーンごとの有効なルールリストを含む辞書
        """
        rules = {
            chain: self[chain].ruler.get_active_rules()
            for chain in ["core", "block", "inline"]
        }
        rules["inline2"] = self.inline.ruler2.get_active_rules()
        return rules

    def enable(
        self, names: str | Iterable[str], ignoreInvalid: bool = False
    ) -> MarkdownIt:
        """
        指定したルールを有効にする

        :param names: ルール名またはルール名のリスト
        :param ignoreInvalid: 無効なルール名を無視する場合は True
        :return: 自身のインスタンス（チェーンメソッド対応）
        """
        result: list[str] = []
        if isinstance(names, str):
            names = [names]

        for chain in ["core", "block", "inline"]:
            result.extend(self[chain].ruler.enable(names, True))
        result.extend(self.inline.ruler2.enable(names, True))

        missed = [name for name in names if name not in result]
        if missed and not ignoreInvalid:
            raise ValueError(f"MarkdownIt. Failed to enable unknown rule(s): {missed}")

        return self

    def disable(
        self, names: str | Iterable[str], ignoreInvalid: bool = False
    ) -> MarkdownIt:
        """
        指定したルールを無効にする

        :param names: ルール名またはルール名のリスト
        :param ignoreInvalid: 無効なルール名を無視する場合は True
        :return: 自身のインスタンス（チェーンメソッド対応）
        """
        result: list[str] = []
        if isinstance(names, str):
            names = [names]

        for chain in ["core", "block", "inline"]:
            result.extend(self[chain].ruler.disable(names, True))
        result.extend(self.inline.ruler2.disable(names, True))

        missed = [name for name in names if name not in result]
        if missed and not ignoreInvalid:
            raise ValueError(f"MarkdownIt. Failed to disable unknown rule(s): {missed}")
        return self

    @contextmanager
    def reset_rules(self) -> Generator[None, None, None]:
        """
        コンテキストマネージャー。終了時に現在の有効なルール状態にリセットする。
        """
        chain_rules = self.get_active_rules()
        try:
            yield
        finally:
            for chain, rules in chain_rules.items():
                if chain != "inline2":
                    self[chain].ruler.enableOnly(rules)
            self.inline.ruler2.enableOnly(chain_rules["inline2"])

    def add_render_rule(
        self, name: str, function: Callable[..., Any], fmt: str = "html"
    ) -> None:
        """
        特定のトークンタイプのレンダリングルールを追加する

        :param name: トークンタイプの名前
        :param function: レンダリング関数
        :param fmt: 対象となる出力フォーマット（デフォルトは "html"）
        """
        if self.renderer.__output__ == fmt:
            # バインドしてルールに登録する
            self.renderer.rules[name] = function.__get__(self.renderer)

    def use(
        self, plugin: Callable[..., None], *params: Any, **options: Any
    ) -> MarkdownIt:
        """
        プラグインをロードして現在のパーサーインスタンスに適用する（チェーン可能）

        :param plugin: プラグイン関数
        :param params: 位置引数
        :param options: キーワード引数
        :return: 自身のインスタンス
        """
        plugin(self, *params, **options)
        return self

    def parse(self, src: str, env: EnvType | None = None) -> list[Token]:
        """
        ソース文字列をパースしてトークンのリストを返す

        :param src: 入力文字列
        :param env: 環境辞書（デフォルトは {}）
        :return: パース結果のトークンリスト
        """
        env = {} if env is None else env
        if not isinstance(env, MutableMapping):
            raise TypeError(f"Input data should be a MutableMapping, not {type(env)}")
        if not isinstance(src, str):
            raise TypeError(f"Input data should be a string, not {type(src)}")
        state = StateCore(src, self, env)
        self.core.process(state)
        return state.tokens

    def render(self, src: str, env: EnvType | None = None) -> Any:
        """
        Markdown の文字列をレンダリングする

        :param src: 入力文字列
        :param env: 環境辞書（デフォルトは {}）
        :return: レンダリング結果
        """
        env = {} if env is None else env
        tokens = self.parse(src, env)
        return self.renderer.render(tokens, self.options, env)

    def parseInline(self, src: str, env: EnvType | None = None) -> list[Token]:
        """
        ブロックルールをスキップしてインラインのみパースする

        :param src: 入力文字列
        :param env: 環境辞書（デフォルトは {}）
        :return: インラインパース結果のトークンリスト（子要素として inline tokens を含む）
        """
        env = {} if env is None else env
        if not isinstance(env, MutableMapping):
            raise TypeError(f"Input data should be a MutableMapping, not {type(env)}")
        if not isinstance(src, str):
            raise TypeError(f"Input data should be a string, not {type(src)}")
        state = StateCore(src, self, env)
        state.inlineMode = True
        self.core.process(state)
        return state.tokens

    def renderInline(self, src: str, env: EnvType | None = None) -> Any:
        """
        単一段落のコンテンツをレンダリングする（<p>タグで囲まれない）

        :param src: 入力文字列
        :param env: 環境辞書（デフォルトは {}）
        :return: レンダリング結果
        """
        env = {} if env is None else env
        tokens = self.parseInline(src, env)
        return self.renderer.render(tokens, self.options, env)

    def validateLink(self, url: str) -> bool:
        """
        出力時にリンクとして許可するか検証する

        :param url: リンク先 URL
        :return: True なら許可、False なら拒否
        """
        return normalize_url.validateLink(url)

    def normalizeLink(self, url: str) -> str:
        """
        リンク先 URL を正規化する

        :param url: 入力 URL
        :return: 正規化された URL
        """
        return normalize_url.normalizeLink(url)

    def normalizeLinkText(self, link: str) -> str:
        """
        自動リンク内のテキストを正規化する

        :param link: 入力リンクテキスト
        :return: 正規化されたリンクテキスト
        """
        return normalize_url.normalizeLinkText(link)
